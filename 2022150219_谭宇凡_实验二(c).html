<html>

<head>
  <style>
    body {
      font-family: Helvetica, Arial, sans-serif
    }

    h1 {
      background-color: steelblue;
      /* TODO 1
            change the text to white and add a padding of 5px
            2 lines of code
            */
      color: white;
      padding: 5px;
    }

    h2 {
      color: gray;
    }

    svg {
      border: 2px gray solid;
    }

    /* TODO 2
        Add code to show a gray border of 2px around all SVGs elements in the page
        1-3 lines of code
        */
    .mainView {
      display: flex;
    }

    /* TODO 3
         - Use the "display flex" feature from to show the items from class `mainView` side by side
         1-3 lines of cide
        */
  </style>
</head>

<body>
  <h1>Global Sales</h1>
  <div class="mainView">
    <div>
      <h2>Categories</h2>
      <svg id="CatergoryChart">
        <g id="rects"></g>
        <g id="xAxis"></g>
        <g id="yAxis"></g>
      </svg>
    </div>
    <div>
      <h2>Areas</h2>
      <svg id="Map"></svg>
    </div>
    <div>
      <h2>Other</h2>
      <svg id="Other"></svg>
    </div>
  </div>
  <script src="d3/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <script>
    var barChartWidth = 480, barChartHeight = 480;
    var barChartPadding = {
      top: 30,
      left: 80,
      bottom: 30,
      right: 30
    };

    var nestBySubCategory;
    var dataUS;
    d3.csv("data/sub-categories-states-sales.csv").then(function (data) {
      var barData = [];
      dataUS = data.filter(function (d) {
        return d.country == "United States";
      });

      dataUS.forEach((item, i) => {
        item.profit = +item.profit;
        item.sales = +item.sales;
      });

      nestBySubCategory = d3.group(dataUS, function (d) {
        return d.subCategory;
      });
      nestBySubCategory.forEach((value, key) => { // 遍历Map结构
        let sumProfit = 0, sumSales = 0;
        value.forEach(d => {
          sumProfit += d.profit;
          sumSales += d.sales;
        });
        barData.push({
          subCategory: key, // 使用Map的key
          profit: sumProfit,
          sales: sumSales
        });
      });
      nestBySubCategory = d3.group(dataUS, d => d.subCategory);
      drawBarChart(barData);
    }).catch(function (error) {
      console.error("Error loading CSV:", error); // 捕获并打印错误
    });

    var usMapData; // 用于存储加载的地图数据

    // 先加载地图数据
    d3.json("data/states-albers-10m.json").then(function (us) {
      usMapData = us; // 存储到全局变量
    }).catch(function (error) {
      console.error("Error loading map data:", error);
    });

    // TODO: 绘制美国各州的利润地图
    d3.csv("data/sub-categories-states-sales.csv").then(function (data) {
      // 过滤出美国数据
      const dataUS = data.filter(d => d.country === "United States");

      // 转换 profit 和 sales 为数字
      dataUS.forEach(d => {
        d.profit = +d.profit;
      });

      // 按州名汇总利润
      const profitMap = d3.rollup(
        dataUS,
        v => d3.sum(v, d => d.profit),
        d => d.state
      );

      drawMap(profitMap);
    });


    function drawBarChart(barData) {

      var barChart = d3.select("#CatergoryChart")
        .attr("width", barChartWidth)
        .attr("height", barChartHeight);
      console.log("Max Sales:" + d3.max(barData, function (d) {
        return d.sales;
      }));
      var xScale = d3.scaleLinear()
        .domain([0, d3.max(barData, function (d) {
          return d.sales;
        })]) // 得到最大销量
        .range([barChartPadding.left, barChartWidth - barChartPadding.right]);

      var yScale = d3.scaleBand()
        .domain(barData.map(function (d) {
          return d.subCategory;
        })) // 得到所有类别信息
        .rangeRound([barChartPadding.top, barChartHeight - barChartPadding.bottom]) // set the output range
        .paddingInner(0.2)
        .paddingOuter(0.3);

      var maxProfit = d3.max(barData, function (d) {
        return d.profit;
      });
      var color = d3.scaleDiverging()
        .domain([-maxProfit, 0, maxProfit])
        .interpolator(d3.interpolateRdBu);

      // 绘制矩形
      var bindings = d3.select("#rects").selectAll("rect")
        .data(Array.from(barData));

      var enterRects = bindings.enter();
      var updateRects = bindings;
      var exitRects = bindings.exit();

      enterRects.append("rect")
        .attr("width", function (d) {
          return xScale(d.sales) - barChartPadding.left; // 销量决定宽度
        })
        // 用比例尺的带宽动态计算矩形高度
        .attr("height", yScale.bandwidth())
        .attr("x", barChartPadding.left) // 从左边缘开始
        .attr("y", function (d, i) {
          return yScale(d.subCategory);
        })
        .style("fill", function (d) {
          return color(d.profit); // 根据利润填充颜色
        });

      updateRects.transition().duration(1000)
        .attr("width", function (d) {
          return xScale(d.sales) - barChartPadding.left; // 销量决定宽度
        })
        // 用比例尺的带宽动态计算矩形高度
        .attr("height", yScale.bandwidth())
        .attr("x", barChartPadding.left) // 从左边缘开始
        .attr("y", function (d, i) {
          return yScale(d.subCategory);
        })
        .style("fill", function (d) {
          return color(d.profit); // 根据利润填充颜色
        });

      exitRects.remove();

      // 绘制 X 轴
      var xAxis = d3.axisBottom(xScale).ticks(3);
      d3.select("#xAxis")
        .attr("transform", "translate(0," + (barChartHeight - barChartPadding.bottom) + ")")
        .call(xAxis);

      // 绘制 Y 轴
      var yAxis = d3.axisLeft(yScale)
        .tickFormat(function (d) {
          return d; // 直接使用类别名称
        })
        .ticks(barData.length);

      d3.select("#yAxis")
        .attr("transform", "translate(" + barChartPadding.left + ",0)")
        .call(yAxis);
    }

    function drawMap(profitMap) {

      // 获取最大和最小利润
      const maxProfit = d3.max([...profitMap.values()]);
      const minProfit = d3.min([...profitMap.values()]);

      // 创建发散颜色比例尺（蓝红渐变）
      const color = d3.scaleDiverging()
        .domain([minProfit, (minProfit + maxProfit) / 2, maxProfit])
        .interpolator(d3.interpolateRdBu); // 蓝红渐变

      // 设置SVG
      const svg = d3.select("#Map")
        .attr("width", 975)
        .attr("height", 610);

      // 创建地理路径生成器
      const path = d3.geoPath();

      // 绘制州边界
      svg.append("g")
        .selectAll("path")
        .data(topojson.feature(usMapData, usMapData.objects.states).features)
        .join("path")
        .attr("class", "state-path")
        .attr("d", path)
        .attr("fill", d => {
          const profit = profitMap.get(d.properties.name);
          return profit ? color(profit) : "#ccc"; // 无数据为灰色
        })
        .append("title")
        .text(d => `${d.properties.name}\nProfit: $${(profitMap.get(d.properties.name) || 0).toFixed(2)}`);

      // 绘制州边界线
      svg.append("g")
        .append("path")
        .datum(topojson.mesh(usMapData, usMapData.objects.states, (a, b) => a !== b))
        .attr("d", path)
        .attr("fill", "none")
        .attr("stroke", "white");

      // 添加图例
      const legend = svg.append("g")
        .attr("transform", "translate(600,30)");

      // 定义等值分段数量（例如5段）
      const segments = 5;
      const legendWidth = 260;
      const legendHeight = 20;

      // 创建离散颜色比例尺
      const colorScale = d3.scaleQuantize()
        .domain([minProfit, maxProfit])
        .range(d3.range(segments).map(i => d3.interpolateRdBu(i / (segments - 1))));

      // 绘制离散颜色块
      legend.selectAll("rect")
        .data(d3.range(segments))
        .join("rect")
        .attr("x", (d, i) => i * (legendWidth / segments))
        .attr("width", legendWidth / segments)
        .attr("height", legendHeight)
        .attr("fill", d => colorScale.range()[d]);

      // 添加图例标题
      legend.append("text")
        .attr("y", -5)
        .text("Profit ($)");

      // 添加刻度轴
      const axisScale = d3.scaleLinear()
        .domain([minProfit, maxProfit])
        .range([0, legendWidth]);

      // 替换ticks()为手动指定刻度值
      const tickValues = d3.range(minProfit, maxProfit, (maxProfit - minProfit) / segments);
      const legendAxis = d3.axisBottom(axisScale)
        .tickValues(tickValues.concat(maxProfit)); // 包含最大值

      legend.append("g")
        .attr("transform", `translate(0,${legendHeight})`)
        .call(legendAxis);
    }
  </script>
</body>

</html>